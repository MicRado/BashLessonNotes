****************************************************************************************************************************************************************************
Good Rules to Follow
****************************************************************************************************************************************************************************
- Always double quote variables, including subshells. No naked $ signs
    - This rule gets you pretty far. Read http://mywiki.wooledge.org/Quotes for details
- All code goes in a function. Even if it's one function, main.
    - Unless a library script, you can do global script settings and call main. That's it.
    - Avoid global variables. Though when defining constants use readonly
- Always have a main function for runnable scripts, called with main or main "$@"
    - If script is also usable as library, call it using [[ "$0" == "$BASH_SOURCE" ]] && main "$@"
- Always use local when setting variables, unless there is reason to use declare
    - Exception being rare cases when you are intentionally setting a variable in an outer scope.
- Variable names should be lowercase unless exported to environment.
- Always use set -eo pipefail. Fail fast and be aware of exit codes.
    - Use || true on programs that you intentionally let exit non-zero.
- Never use deprecated style. Most notably:
    - Define functions as myfunc() { ... }, not function myfunc { ... }
    - Always use [[ instead of [ or test
    - Never use backticks, use $( ... )
        - See http://wiki.bash-hackers.org/scripting/obsolete for more
- Prefer absolute paths (leverage $PWD), always qualify relative paths with ./.
- Always use declare and name variable arguments at the top of functions that are more than 2-lines
    - Example: declare arg1="$1" arg2="$2"
    - The exception is when defining variadic functions. See below.
- Use mktemp for temporary files, always cleanup with a trap.
- Warnings and errors should go to STDERR, anything parsable should go to STDOUT.
- Try to localize shopt usage and disable option when finished.

****************************************************************************************************************************************************************************
Best Practices and Tips
****************************************************************************************************************************************************************************
- Use Bash variable substitution if possible before awk/sed.
- Generally use double quotes unless it makes more sense to use single quotes.
- For simple conditionals, try using && and ||.
- Don't be afraid of printf, it's more powerful than echo.
- Put then, do, etc on same line, not newline.
- Skip [[ ... ]] in your if-expression if you can test for exit code instead.
- Use .sh or .bash extension if file is meant to be included/sourced. Never on executable script.
- Put complex one-liners of sed, perl, etc in a standalone function with a descriptive name.
- Good idea to include [[ "$TRACE" ]] && set -x
- Design for simplicity and obvious usage.
    - Avoid option flags and parsing, try optional environment variables instead.
    - Use subcommands for necessary different "modes".
- In large systems or for any CLI commands, add a description to functions.
    - Use - declare desc="description" at the top of functions, even above argument declaration.
    - This can be queried/extracted using reflection. For example:
EXAMPLE:
eval $(type FUNCTION_NAME | grep 'declare desc=') && echo "$desc"

- Be conscious of the need for portability. Bash to run in a container can make more assumptions than Bash made to run on multiple platforms.
- When expecting or exporting environment, consider namespacing variables when subshells may be involved.
- Use hard tabs. Heredocs ignore leading tabs, allowing better indentation.

****************************************************************************************************************************************************************************
Expand argument lists
****************************************************************************************************************************************************************************
Double-quoting $@ or ${array[@]} has a special meaning. "$@" expands to a list of words, with each positional parameter's value being one word. Likewise, "${array[@]}" expands to a list of words, one per array element. When dealing with the positional parameters or with the contents of an array as a list of words, always use the double-quoted syntax.

Double-quoting $* or ${array[*]} results in one word which is the concatenation of all the positional parameters (or array elements) with the first character of IFS between them. This is similar to the join function in some other languages, although the fact that you can only have a single join character can sometimes be a crippling limitation.

****************************************************************************************************************************************************************************
Using Quotes
****************************************************************************************************************************************************************************
In many languages, quotes are primarily used to denote string literals. In the shell paradigm, many constructs are interpreted as strings by default, so quotes play other important roles. Quotes demarcate the arguments of a command into units called "words", as well as modify the evaluation of their contents in numerous context-dependent ways. It is critical to understand how quoting affects the interpretation of code in a given context; it's something no one should avoid learning. Improper quoting is among the most common shell programming errors. Do not guess about quotes!

cp $file $destination         # WRONG
cp -- "$file" "$destination"  # RIGHT

Types of quoting
There are three standard types of quotes (or four if you count backslash escaping), and two nonstandard Bash extensions.

Single quotes: 
    '...' removes the special meaning of every character between the quotes. Everything inside single quotes becomes a literal string. The only character that you can't           safely enclose in single quotes is a single quote.

Double quotes: 
    "..." prevents some substitutions but allows others. Every substitution that begins with a dollar sign $ is performed, as is the legacy `...` (backtick) command               substitution. Backslash escaping is also performed. No word splitting or filename expansion is performed.

Backticks: 
    `...` is the legacy command substitution syntax; deprecated in favor of $(...) but still permitted for historical reasons. 

Backslash: 
    Putting \ in front of a metacharacter removes its special meaning. This works inside double quotes, or in the absence of quotes. It does not work inside single quotes.

$'...': 
    Contents are a single word with interpretation of backslash escape sequences such as \n for newline, \t for tab, and \xnn for bytes specified in hexadecimal. These may be     used to specify a text representation of arbitrary data. No current implementation supports a context where these are not interpreted as NUL-terminated C strings.

You can mix the various types of quoting if you need to. For example, if you have one section of a string that has lots of special characters that you'd like to single-quote, and another section with a parameter expansion in it which must be double-quoted.

$ foo=bar
$ printf '%s\n' '!%$*&'"$foo"
!%$*&bar


















































